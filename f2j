function f2j() {
    # Identificar shell
    if [ -n "$ZSH_VERSION" ]; then
        is_zsh=true
    elif [ -n "$BASH_VERSION" ]; then
        is_bash=true
    else
        echo -e "\033[1;31m‚ùå Erro: Shell n√£o suportado. Use bash ou zsh.\033[0m" >&2
        return 1
    fi

    # Verificar depend√™ncias
    if ! command -v xclip &> /dev/null; then
        echo -e "\033[1;31m‚ùå Erro: xclip n√£o est√° instalado!\033[0m"
        echo "Instale com:"
        echo "  Ubuntu/Debian: sudo apt install xclip"
        echo "  Fedora/RHEL: sudo dnf install xclip"
        echo "  Arch: sudo pacman -S xclip"
        return 1
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "\033[1;31m‚ùå Erro: jq n√£o est√° instalado!\033[0m"
        echo "Instale com:"
        echo "  Ubuntu/Debian: sudo apt install jq"
        echo "  Fedora/RHEL: sudo dnf install jq"
        echo "  Arch: sudo pacman -S jq"
        return 1
    fi

    # Configura√ß√£o de blocos
    typeset -A blocos=(
        [laravel]="README.md .env config/ app/Http/Controllers/ app/Models/ resources/views/ routes/web.php routes/api.php database/migrations/ database/seeders/ composer.json package.json webpack.mix.js public/ routes/ tests/"
        [infra]="Makefile Vagrantfile ansible/ monitoring/ nginx.conf apache2.conf postgresql.conf redis.conf ssl/ vault/"
        # [cloud]="terraform/"   # Comentado, mas dispon√≠vel se necess√°rio
        [ignorados]="storage/logs/ storage/framework/ vendor/ node_modules/ .git/ .idea/ *.log *.tmp *.swp"
        [docker]="docker/"   # Tudo dentro de docker/, recursivamente
        [all]="."   # Diret√≥rio atual
    )

    typeset -A arquivos_blocos=()
    local outros_arquivos=()
    local arquivos_todos=()

    # Mensagem de ajuda
    if (( $# == 0 )); then
        echo -e "\n\033[1;34müåÄ f2j - Conversor de Arquivos para JSON\033[0m"
        echo "Uso: f2j [blocos] [arquivos/padr√µes]"
        echo -e "\n\033[1;36mBlocos Dispon√≠veis:\033[0m"

        # Listar blocos de acordo com o shell
        if [ -n "$is_zsh" ]; then
            for bloco in "${(@k)blocos}"; do
                echo "  $bloco: ${blocos[$bloco]}"
            done | sort
        else
            for bloco in "${!blocos[@]}"; do
                echo "  $bloco: ${blocos[$bloco]}"
            done | sort
        fi

        echo -e "\n\033[1;36mExemplos:\033[0m"
        echo "  f2j laravel docker *.sh"
        echo "  f2j infra Dockerfile"
        echo "  f2j docker"
        return 1
    fi

    # Processamento de argumentos
    for arg in "$@"; do
        if [ -n "$is_zsh" ]; then
            # No zsh: verifica√ß√£o correta de chaves
            if [[ -v blocos[$arg] ]]; then
                for caminho in ${=blocos[$arg]}; do
                    if [ -d "$caminho" ]; then
                        while IFS= read -r -d $'\0' arquivo; do
                            if [ -z "${arquivos_blocos[$arg]}" ]; then
                                arquivos_blocos[$arg]="$arquivo"
                            else
                                arquivos_blocos[$arg]+=$'\0'"$arquivo"
                            fi
                        done < <(find "$caminho" -type f -print0 2>/dev/null)
                    elif [ -f "$caminho" ]; then
                        if [ -z "${arquivos_blocos[$arg]}" ]; then
                            arquivos_blocos[$arg]="$caminho"
                        else
                            arquivos_blocos[$arg]+=$'\0'"$caminho"
                        fi
                    fi
                done
            fi
        else
            # No bash
            if [[ -n "${blocos[$arg]+_}" ]]; then
                for caminho in ${blocos[$arg]}; do
                    if [ -d "$caminho" ]; then
                        while IFS= read -r -d $'\0' arquivo; do
                            if [ -z "${arquivos_blocos[$arg]}" ]; then
                                arquivos_blocos[$arg]="$arquivo"
                            else
                                arquivos_blocos[$arg]+=$'\0'"$arquivo"
                            fi
                        done < <(find "$caminho" -type f -print0 2>/dev/null)
                    elif [ -f "$caminho" ]; then
                        if [ -z "${arquivos_blocos[$arg]}" ]; then
                            arquivos_blocos[$arg]="$caminho"
                        else
                            arquivos_blocos[$arg]+=$'\0'"$caminho"
                        fi
                    fi
                done
            fi
        fi

        # Processa arquivo comum (para ambos shells)
        for file in $arg; do
            [ -f "$file" ] || continue
            outros_arquivos+=("$file")
        done
    done

    # Coleta todos os arquivos
    if [ -n "$is_zsh" ]; then
        for bloco in "${(@k)arquivos_blocos}"; do
            IFS=$'\0' read -r -A files_bloco <<< "${arquivos_blocos[$bloco]}"
            arquivos_todos+=("${files_bloco[@]}")
        done
    else
        for bloco in "${!arquivos_blocos[@]}"; do
            IFS=$'\0' read -r -a files_bloco <<< "${arquivos_blocos[$bloco]}"
            arquivos_todos+=("${files_bloco[@]}")
        done
    fi
    arquivos_todos+=("${outros_arquivos[@]}")

    # Verifica√ß√£o de arquivos
    if (( ${#arquivos_todos[@]} == 0 )); then
        echo -e "\n\033[1;31m‚ùå Nenhum arquivo v√°lido encontrado!\033[0m" >&2
        return 1
    fi

    # Processamento JSON
    local json_output=() temp_file=$(mktemp)

    for file in "${arquivos_todos[@]}"; do
        if grep -Iq . "$file" 2>/dev/null; then
            if content=$(jq -Rs --arg path "$file" '{path: $path, content: .}' < "$file" 2>/dev/null); then
                json_output+=("$content")
            else
                echo -e "\033[33m‚ö†Ô∏è Erro ao processar: $file\033[0m" >&2
            fi
        else
            echo -e "\033[33m‚ö†Ô∏è Ignorando bin√°rio: $file\033[0m" >&2
        fi
    done

    # Sa√≠da final
    if (( ${#json_output[@]} > 0 )); then
        printf '%s\n' "${json_output[@]}" | jq -s '.' > "$temp_file"
        xclip -sel c < "$temp_file" 2>/dev/null || echo -e "\033[33m‚ö†Ô∏è xclip n√£o encontrado. Cole manualmente do arquivo tempor√°rio\033[0m"

        echo -e "\n\033[1;34müì¶ Resultados Agrupados:\033[0m"

        # Listar blocos de acordo com o shell
        if [ -n "$is_zsh" ]; then
            for bloco in "${(@k)arquivos_blocos}"; do
                IFS=$'\0' read -r -A files_bloco <<< "${arquivos_blocos[$bloco]}"
                echo -e "\n\033[1;32m‚óè Bloco [$bloco] (${#files_bloco[@]} arquivos):\033[0m"
                printf '%s\n' "${files_bloco[@]}"
            done
        else
            for bloco in "${!arquivos_blocos[@]}"; do
                IFS=$'\0' read -r -a files_bloco <<< "${arquivos_blocos[$bloco]}"
                echo -e "\n\033[1;32m‚óè Bloco [$bloco] (${#files_bloco[@]} arquivos):\033[0m"
                printf '%s\n' "${files_bloco[@]}"
            done
        fi

        if (( ${#outros_arquivos[@]} > 0 )); then
            echo -e "\n\033[1;32m‚óè Outros Arquivos (${#outros_arquivos[@]}):\033[0m"
            printf '%s\n' "${outros_arquivos[@]}"
        fi

        echo -e "\n\033[1;32m‚úÖ Total de ${#json_output[@]} arquivo(s) convertidos para JSON!\033[0m"
        echo -e "\033[1;36müìã JSON copiado para √°rea de transfer√™ncia\033[0m"
    else
        echo -e "\033[1;31m‚ùå Nenhum arquivo v√°lido para convers√£o!\033[0m" >&2
        return 1
    fi

    rm -f "$temp_file"
}

function json() {
    f2j "$@"
}
